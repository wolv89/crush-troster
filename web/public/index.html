<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Troster - Tennis Fixture Roster</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #eef1f5;
      color: #1a1a2e;
      line-height: 1.4;
    }

    header {
      background: #1a3050;
      color: white;
      padding: 14px 24px;
    }

    header h1 { font-size: 1.4rem; font-weight: 600; }
    header .subtitle { font-size: 0.85rem; opacity: 0.8; }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px 24px;
      padding-bottom: 50vh;
    }

    .config-bar {
      background: white;
      border: 1px solid #d0d5dd;
      border-radius: 6px;
      padding: 10px 16px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
      font-size: 0.85rem;
    }

    .config-bar .item { display: flex; gap: 5px; }
    .config-bar .label { font-weight: 600; color: #555; }

    .config-bar .seed-controls {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .config-bar .seed-controls label {
      font-weight: 600;
      color: #555;
    }

    .config-bar .seed-controls input {
      width: 100px;
      padding: 5px 8px;
      border: 1px solid #d0d5dd;
      border-radius: 4px;
      font-size: 0.85rem;
    }

    .config-bar .seed-controls button {
      padding: 5px 14px;
      border: 1px solid #d0d5dd;
      border-radius: 4px;
      background: #f8f9fa;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .config-bar .seed-controls button:hover { background: #e9ecef; }

    .config-bar .seed-controls button.shuffle {
      background: #1a3050;
      color: white;
      border-color: #1a3050;
    }

    .config-bar .seed-controls button.shuffle:hover { background: #15283f; }

    .roster-grid {
      margin-bottom: 28px;
      overflow-x: auto;
    }

    .roster-grid table {
      width: 100%;
      border-collapse: collapse;
      min-width: 600px;
    }

    .roster-grid thead th {
      background: #1a3050;
      color: white;
      padding: 10px 12px;
      font-size: 0.85rem;
      font-weight: 600;
      text-align: center;
      border: 1px solid #15283f;
      white-space: nowrap;
    }

    .roster-grid thead th.date-col {
      width: 56px;
      text-align: right;
      padding-right: 12px;
    }

    .month-row td {
      background: #2c5282;
      color: white;
      padding: 5px 14px;
      font-weight: 600;
      font-size: 0.85rem;
      border: none;
    }

    .roster-grid tbody td {
      padding: 8px 6px;
      text-align: center;
      font-size: 0.85rem;
      border: 1px solid rgba(255, 255, 255, 0.35);
      vertical-align: middle;
    }

    .row-even td { background: #c5d1e0; }
    .row-odd td { background: #adbdd2; }

    .date-cell {
      text-align: right !important;
      padding-right: 12px !important;
      font-weight: 600;
      white-space: nowrap;
      width: 56px;
    }

    .roster-cell {
      min-width: 110px;
      cursor: default;
      position: relative;
      user-select: none;
    }

    .roster-cell.has-assignment { cursor: pointer; }

    .roster-cell.selected {
      outline: 3px solid #e53e3e;
      outline-offset: -3px;
      z-index: 1;
    }

    .roster-cell.swap-target {
      outline: 2px dashed #e53e3e;
      outline-offset: -2px;
    }

    .court-group {
      font-weight: 700;
      font-size: 0.9rem;
    }

    .vs-opponent {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-top: 1px;
    }

    .overflow-warning {
      color: #c53030;
      font-size: 0.8rem;
      font-weight: 700;
    }

    .stats-section {
      position: fixed;
      bottom: 16px;
      right: 16px;
      z-index: 100;
      max-height: 50vh;
      overflow-y: auto;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.25);
      background: white;
      border: 1px solid #d0d5dd;
    }

    .stats-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 14px;
      cursor: pointer;
      user-select: none;
      background: #1a3050;
      color: white;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .stats-section.open .stats-toggle {
      border-radius: 8px 8px 0 0;
    }

    .stats-toggle .toggle-icon {
      margin-left: 10px;
      font-size: 0.7rem;
    }

    .stats-table {
      border-collapse: collapse;
      background: white;
      overflow: hidden;
    }

    .stats-table thead th {
      background: #f0f2f5;
      padding: 8px 10px;
      font-size: 0.8rem;
      font-weight: 600;
      text-align: center;
      border-bottom: 2px solid #d0d5dd;
      border-right: 1px solid #d0d5dd;
      color: #555;
    }

    .stats-table thead th.team-header {
      text-align: left;
      padding-left: 14px;
    }

    .stats-table thead th.cg-header {
      background: #1a3050;
      color: white;
    }

    .stats-table thead th.cg-border {
      border-right: 2px solid #d0d5dd;
    }

    .stats-table thead th.sub-header {
      font-size: 0.7rem;
      padding: 4px 8px;
      text-transform: uppercase;
    }

    .stats-table tbody td {
      padding: 6px 10px;
      font-size: 0.85rem;
      text-align: center;
      border-bottom: 1px solid #eee;
      border-right: 1px solid #eee;
    }

    .stats-table tbody td.team-name {
      text-align: left;
      padding-left: 14px;
      font-weight: 500;
    }

    .stats-table tbody td.total-col {
      font-weight: 600;
    }

    .stats-table .group-border {
      border-right: 2px solid #d0d5dd;
    }

    .loading {
      text-align: center;
      padding: 60px;
      color: #999;
      font-size: 1.1rem;
    }

    .error {
      text-align: center;
      padding: 60px;
      color: #c0392b;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    function mulberry32(seed) {
      return function() {
        seed |= 0;
        seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function shuffle(arr, rng) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function stripTime(name) {
      return name.replace(/\s*\([\d:]+\)\s*$/, '').trim();
    }

    function isClubTeam(teamName, clubName) {
      return teamName.toLowerCase().includes(clubName.toLowerCase());
    }

    function parseDate(dateStr) {
      const months = { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };
      const parts = dateStr.trim().split(/\s+/);
      if (parts.length < 3) return new Date(0);
      return new Date(2000 + parseInt(parts[2]), months[parts[1]] || 0, parseInt(parts[0]));
    }

    function getMonthKey(dateStr) {
      const d = parseDate(dateStr);
      return d.getFullYear() + '-' + d.getMonth();
    }

    function getMonthLabel(dateStr) {
      return parseDate(dateStr).toLocaleString('default', { month: 'long' });
    }

    function getDayOrdinal(dateStr) {
      const day = parseInt(dateStr.trim().split(/\s+/)[0]);
      const s = ['th', 'st', 'nd', 'rd'];
      const v = day % 100;
      return day + (s[(v - 20) % 10] || s[v] || s[0]);
    }

    function shortName(teamLabel, clubName) {
      const escaped = clubName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const short = teamLabel.replace(new RegExp(escaped + '\\s*', 'i'), '').trim();
      return short || teamLabel;
    }

    function getCourtGroups(totalCourts, courtsPerTeam) {
      const groups = [];
      const numGroups = Math.floor(totalCourts / courtsPerTeam);
      for (let i = 0; i < numGroups; i++) {
        const start = i * courtsPerTeam + 1;
        const courts = [];
        for (let j = 0; j < courtsPerTeam; j++) courts.push(start + j);
        groups.push(courts.join(' / '));
      }
      return groups;
    }

    function buildRosterData(data) {
      const clubName = data.config.club_name;
      const teams = data.fixtures.map(f => f.team.label);
      const teamSections = {};
      data.fixtures.forEach(f => { teamSections[f.team.label] = f.section.label; });

      const cellData = {};
      const allDates = new Set();

      data.fixtures.forEach(tf => {
        const teamLabel = tf.team.label;
        tf.rounds.forEach(r => {
          if (r.no_play || (!r.home_team && !r.away_team)) return;
          allDates.add(r.date);
          if (!cellData[r.date]) cellData[r.date] = {};

          const homeStripped = stripTime(r.home_team);
          const awayStripped = stripTime(r.away_team);

          if (homeStripped.toLowerCase() === teamLabel.toLowerCase()) {
            cellData[r.date][teamLabel] = {
              status: isClubTeam(r.away_team, clubName) ? 'home_intra' : 'home',
              opponent: awayStripped,
            };
          } else if (awayStripped.toLowerCase() === teamLabel.toLowerCase()) {
            cellData[r.date][teamLabel] = {
              status: isClubTeam(r.home_team, clubName) ? 'away_intra' : 'away_external',
              opponent: homeStripped,
            };
          }
        });
      });

      const sortedDates = [...allDates].sort((a, b) => parseDate(a) - parseDate(b));

      const months = [];
      let currentKey = '';
      sortedDates.forEach(d => {
        const key = getMonthKey(d);
        if (key !== currentKey) {
          months.push({ label: getMonthLabel(d), dates: [] });
          currentKey = key;
        }
        months[months.length - 1].dates.push(d);
      });

      return { teams, teamSections, cellData, sortedDates, months };
    }

    function assignCourts(rosterData, courtGroups, seed) {
      const rng = mulberry32(seed);
      const { teams, cellData, sortedDates } = rosterData;
      const assignments = {};
      const courtCounts = {};

      teams.forEach(t => {
        courtCounts[t] = {};
        courtGroups.forEach(g => { courtCounts[t][g] = 0; });
      });

      sortedDates.forEach(date => {
        const dateCells = cellData[date] || {};
        const homeTeams = teams.filter(t => {
          const cell = dateCells[t];
          return cell && (cell.status === 'home' || cell.status === 'home_intra');
        });

        if (homeTeams.length === 0) return;

        assignments[date] = {};
        const available = [...courtGroups];
        const shuffled = shuffle(homeTeams, rng);

        for (const team of shuffled) {
          if (available.length === 0) break;

          const shuffledAvail = shuffle(available, rng);
          let bestGroup = shuffledAvail[0];
          let bestCount = courtCounts[team][shuffledAvail[0]] || 0;

          for (let i = 1; i < shuffledAvail.length; i++) {
            const count = courtCounts[team][shuffledAvail[i]] || 0;
            if (count < bestCount) {
              bestCount = count;
              bestGroup = shuffledAvail[i];
            }
          }

          assignments[date][team] = bestGroup;
          courtCounts[team][bestGroup]++;
          available.splice(available.indexOf(bestGroup), 1);
        }
      });

      return assignments;
    }

    function computeStats(rosterData, assignments, courtGroups) {
      const { teams, cellData, sortedDates } = rosterData;
      const stats = {};

      teams.forEach(t => {
        stats[t] = {};
        courtGroups.forEach(g => { stats[t][g] = { home: 0, away: 0 }; });
      });

      sortedDates.forEach(date => {
        const dateAssigns = assignments[date] || {};
        const dateCells = cellData[date] || {};

        Object.entries(dateAssigns).forEach(([team, group]) => {
          if (stats[team] && stats[team][group]) {
            stats[team][group].home++;
          }

          const cell = dateCells[team];
          if (cell && cell.status === 'home_intra') {
            const oppLabel = rosterData.teams.find(
              t => t.toLowerCase() === cell.opponent.toLowerCase()
            );
            if (oppLabel && stats[oppLabel] && stats[oppLabel][group]) {
              stats[oppLabel][group].away++;
            }
          }
        });
      });

      return stats;
    }

    function App() {
      const [data, setData] = useState(null);
      const [error, setError] = useState(null);
      const [appliedSeed, setAppliedSeed] = useState(42);
      const [seedInput, setSeedInput] = useState('42');
      const [assignments, setAssignments] = useState({});
      const [selectedCell, setSelectedCell] = useState(null);
      const [refreshKey, setRefreshKey] = useState(0);

      const rosterData = useMemo(() => data ? buildRosterData(data) : null, [data]);

      const courtGroups = useMemo(() => {
        if (!data) return [];
        return getCourtGroups(data.config.total_courts, data.config.courts_per_team);
      }, [data]);

      useEffect(() => {
        if (rosterData && courtGroups.length > 0) {
          setAssignments(assignCourts(rosterData, courtGroups, appliedSeed));
          setSelectedCell(null);
        }
      }, [rosterData, courtGroups, appliedSeed, refreshKey]);

      const stats = useMemo(() => {
        if (!rosterData || !courtGroups.length) return {};
        return computeStats(rosterData, assignments, courtGroups);
      }, [rosterData, assignments, courtGroups]);

      useEffect(() => {
        fetch("/api/fixtures")
          .then(r => {
            if (!r.ok) throw new Error("Failed to load fixture data");
            return r.json();
          })
          .then(setData)
          .catch(e => setError(e.message));
      }, []);

      function handleRefresh() {
        const s = parseInt(seedInput) || 0;
        if (s === appliedSeed) {
          setRefreshKey(k => k + 1);
        } else {
          setAppliedSeed(s);
        }
      }

      function handleShuffle() {
        const s = Math.floor(Math.random() * 100000);
        setSeedInput(String(s));
        setAppliedSeed(s);
      }

      function handleKeyDown(e) {
        if (e.key === 'Enter') handleRefresh();
      }

      function handleCellClick(date, team) {
        const hasAssignment = !!(assignments[date] && assignments[date][team]);

        if (!selectedCell) {
          if (hasAssignment) setSelectedCell({ date, team });
          return;
        }

        if (selectedCell.date === date && selectedCell.team === team) {
          setSelectedCell(null);
          return;
        }

        if (selectedCell.date === date && hasAssignment) {
          const newAssignments = { ...assignments, [date]: { ...assignments[date] } };
          const a = newAssignments[date];
          const tmp = a[selectedCell.team];
          a[selectedCell.team] = a[team];
          a[team] = tmp;
          setAssignments(newAssignments);
          setSelectedCell(null);
          return;
        }

        setSelectedCell(hasAssignment ? { date, team } : null);
      }

      if (error) return <div className="error"><h2>Error</h2><p>{error}</p></div>;
      if (!data) return <div className="loading">Loading fixtures...</div>;

      const clubName = data.config.club_name;

      return (
        <div>
          <header>
            <h1>Troster</h1>
            <div className="subtitle">{data.competition.label} &mdash; {clubName}</div>
          </header>
          <div className="container">
            <ConfigBar
              config={data.config}
              scrapedAt={data.scraped_at}
              seedInput={seedInput}
              onSeedChange={e => setSeedInput(e.target.value)}
              onSeedKeyDown={handleKeyDown}
              onRefresh={handleRefresh}
              onShuffle={handleShuffle}
            />
            <RosterGrid
              rosterData={rosterData}
              assignments={assignments}
              courtGroups={courtGroups}
              clubName={clubName}
              selectedCell={selectedCell}
              onCellClick={handleCellClick}
            />
            <CourtStats
              rosterData={rosterData}
              stats={stats}
              courtGroups={courtGroups}
              clubName={clubName}
            />
          </div>
        </div>
      );
    }

    function ConfigBar({ config, scrapedAt, seedInput, onSeedChange, onSeedKeyDown, onRefresh, onShuffle }) {
      const scraped = new Date(scrapedAt).toLocaleString();
      return (
        <div className="config-bar">
          <div className="item"><span className="label">Courts:</span> {config.total_courts}</div>
          <div className="item"><span className="label">Per team:</span> {config.courts_per_team}</div>
          <div className="item"><span className="label">Data from:</span> {scraped}</div>
          <div className="seed-controls">
            <label>Seed:</label>
            <input
              type="number"
              value={seedInput}
              onChange={onSeedChange}
              onKeyDown={onSeedKeyDown}
            />
            <button onClick={onRefresh}>Refresh</button>
            <button className="shuffle" onClick={onShuffle}>Shuffle</button>
          </div>
        </div>
      );
    }

    function RosterGrid({ rosterData, assignments, courtGroups, clubName, selectedCell, onCellClick }) {
      const { teams, months, cellData } = rosterData;

      return (
        <div className="roster-grid">
          <table>
            <thead>
              <tr>
                <th className="date-col"></th>
                {teams.map(t => (
                  <th key={t}>{shortName(t, clubName)}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {months.map(({ label, dates }) => (
                <React.Fragment key={label}>
                  <tr className="month-row">
                    <td colSpan={teams.length + 1}>{label}</td>
                  </tr>
                  {dates.map((date, di) => {
                    const dateCells = cellData[date] || {};
                    const dateAssigns = assignments[date] || {};
                    return (
                      <tr key={date} className={di % 2 === 0 ? 'row-even' : 'row-odd'}>
                        <td className="date-cell">{getDayOrdinal(date)}</td>
                        {teams.map(t => {
                          const cell = dateCells[t];
                          const group = dateAssigns[t];
                          const isHome = cell && (cell.status === 'home' || cell.status === 'home_intra');
                          const isSelected = selectedCell && selectedCell.date === date && selectedCell.team === t;
                          const isSwapTarget = selectedCell && selectedCell.date === date && selectedCell.team !== t && isHome;

                          const classes = ['roster-cell'];
                          if (isHome) classes.push('has-assignment');
                          if (isSelected) classes.push('selected');
                          if (isSwapTarget) classes.push('swap-target');

                          return (
                            <td
                              key={t}
                              className={classes.join(' ')}
                              onClick={() => onCellClick(date, t)}
                            >
                              {isHome && group && (
                                <div>
                                  <div className="court-group">{group}</div>
                                  {cell.status === 'home_intra' && (
                                    <div className="vs-opponent">vs {shortName(cell.opponent, clubName)}</div>
                                  )}
                                </div>
                              )}
                              {isHome && !group && (
                                <div className="overflow-warning">!!</div>
                              )}
                            </td>
                          );
                        })}
                      </tr>
                    );
                  })}
                </React.Fragment>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function CourtStats({ rosterData, stats, courtGroups, clubName }) {
      const [open, setOpen] = useState(false);
      const { teams } = rosterData;

      return (
        <div className={'stats-section' + (open ? ' open' : '')}>
          <div className="stats-toggle" onClick={() => setOpen(o => !o)}>
            Court Usage
            <span className="toggle-icon">{open ? '\u25BC' : '\u25B2'}</span>
          </div>
          {open && <table className="stats-table">
            <thead>
              <tr>
                <th className="team-header" rowSpan="2">Team</th>
                {courtGroups.map((g, i) => (
                  <th
                    key={g}
                    className={'cg-header' + (i < courtGroups.length - 1 ? ' cg-border' : '')}
                    colSpan="3"
                  >{g}</th>
                ))}
              </tr>
              <tr>
                {courtGroups.map((g, gi) => (
                  <React.Fragment key={g}>
                    <th className="sub-header">H</th>
                    <th className="sub-header">A</th>
                    <th className={'sub-header' + (gi < courtGroups.length - 1 ? ' group-border' : '')}
                    >T</th>
                  </React.Fragment>
                ))}
              </tr>
            </thead>
            <tbody>
              {teams.map(t => (
                <tr key={t}>
                  <td className="team-name">{shortName(t, clubName)}</td>
                  {courtGroups.map((g, gi) => {
                    const s = (stats[t] && stats[t][g]) || { home: 0, away: 0 };
                    return (
                      <React.Fragment key={g}>
                        <td>{s.home}</td>
                        <td>{s.away}</td>
                        <td className={'total-col' + (gi < courtGroups.length - 1 ? ' group-border' : '')}
                        >{s.home + s.away}</td>
                      </React.Fragment>
                    );
                  })}
                </tr>
              ))}
            </tbody>
          </table>}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
